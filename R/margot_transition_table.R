#' Format a Transition Table with observed‑indicator filtering
#'
#' Reshapes a long‑format transition frequency data frame into a
#' wide‑format table with totals, and formats it using markdown.
#' Diagonal elements are bolded to highlight state stability.
#'
#' @param data a data frame containing your id, state, wave, and (optionally) an observed indicator.
#' @param state_var name of the column indicating the state at each wave.
#' @param id_var    name of the column identifying each participant.
#' @param wave_var  name of the column indicating the wave (numeric or factor).
#' @param waves     optional numeric vector of waves to include (defaults to all present in data).
#' @param state_names optional character vector of labels for each state.
#' @param observed_var optional name of a column marking participants still observed.
#' @param observed_val value in \code{observed_var} that denotes “observed” (default 1).
#' @param table_name name for the output object (default "transition_table").
#'
#' @return an object of class \code{margot_transitions} with
#'   \code{tables}, \code{explanation}, \code{wave_info}, and a
#'   \code{quarto_code} helper.
#' @export
margot_transition_table <- function(data, state_var, id_var, wave_var,
                                    waves = NULL, state_names = NULL,
                                    observed_var = NULL, observed_val = 1,
                                    table_name = "transition_table") {
  # filter by observed indicator if requested
  if (!is.null(observed_var)) {
    if (! observed_var %in% names(data)) {
      stop(sprintf("observed_var '%s' not found in data", observed_var))
    }
    data <- data[data[[observed_var]] == observed_val, , drop = FALSE]
  }

  if (is.null(waves)) {
    waves <- sort(unique(data[[wave_var]]))
  }
  waves <- sort(waves)

  results <- list(tables = list(), waves = list(), table_name = table_name)
  results$explanation <- paste0(
    "These transition matrices capture shifts in states between consecutive waves. ",
    "Each cell shows the count of individuals transitioning from one state to another. ",
    "Rows are the initial state (From), columns the subsequent state (To). ",
    "**Diagonal entries** (in **bold**) mark those who stayed in the same state."
  )

  for (i in seq_len(length(waves) - 1)) {
    w1 <- waves[i]; w2 <- waves[i + 1]

    dat_pair <- data[data[[wave_var]] %in% c(w1, w2), , drop = FALSE]
    tmp <- data.frame(
      id    = dat_pair[[id_var]],
      wave  = dat_pair[[wave_var]],
      state = dat_pair[[state_var]]
    )

    wide <- reshape(tmp, idvar = "id", timevar = "wave", direction = "wide")
    from_col <- paste0("state.", w1)
    to_col   <- paste0("state.", w2)

    ok <- !is.na(wide[[from_col]]) & !is.na(wide[[to_col]])
    from_states <- wide[[from_col]][ok]
    to_states   <- wide[[to_col]][ok]

    transition_matrix <- table(from = from_states, to = to_states)

    # skip empty transitions
    if (nrow(transition_matrix) == 0 || ncol(transition_matrix) == 0) {
      warning("no observed transitions for waves ", w1, "→", w2, "; skipping")
      next
    }

    all_states <- sort(unique(c(rownames(transition_matrix), colnames(transition_matrix))))
    labels     <- if (is.null(state_names)) paste0("State ", all_states) else state_names

    trans_df <- as.data.frame.matrix(transition_matrix)
    trans_df$from <- rownames(trans_df)
    long_df <- tidyr::pivot_longer(trans_df, cols = -from,
                                   names_to = "to", values_to = "Freq")

    res <- transition_table(long_df,
                            state_names = labels,
                            wave_info   = paste0("Wave ", w1, " → Wave ", w2),
                            table_name  = table_name)

    results$tables[[i]] <- res$table
    results$waves[[i]]  <- c(w1, w2)
  }

  results$quarto_code <- function() {
    cat(sprintf("```{r, results='asis'}\ncat(%s$explanation)\n```\n\n", table_name))
    for (i in seq_along(results$tables)) {
      w1 <- results$waves[[i]][1]; w2 <- results$waves[[i]][2]
      cat(sprintf(
        "```{r}\n#| label: %s-wave%s-%s\n#| tbl-cap: \"Transition Matrix: Wave %s → %s\"\n%s$tables[[%d]]\n```\n\n",
        table_name, w1, w2, w1, w2, table_name, i
      ))
    }
  }

  class(results) <- c("margot_transitions", class(results))
  results
}

#' @describeIn transition_table helper to format a single transition data frame
#' @export
transition_table <- function(trans_df, state_names = NULL,
                             wave_info = NULL, table_name = "transition_table") {
  required_cols <- c("from", "to", "Freq")
  if (!all(required_cols %in% colnames(trans_df))) {
    stop("trans_df must contain columns: from, to, and Freq")
  }

  trans_wide <- tidyr::pivot_wider(
    trans_df,
    id_cols     = "from",
    names_from  = "to",
    values_from = "Freq",
    values_fill = 0
  )
  trans_wide$Total <- rowSums(trans_wide[, -1], na.rm = TRUE)
  colnames(trans_wide)[1] <- "From / To"

  if (!is.null(state_names)) {
    mapping <- setNames(state_names, sort(unique(c(trans_df$from, trans_df$to))))
    trans_wide[["From / To"]] <- mapping[as.character(trans_wide[["From / To"]])]
    for (j in 2:(ncol(trans_wide) - 1)) {
      old <- colnames(trans_wide)[j]
      if (old %in% names(mapping)) colnames(trans_wide)[j] <- mapping[old]
    }
  }

  formatted <- knitr::kable(trans_wide, format = "markdown")
  # bold diagonal
  for (r in seq_len(nrow(trans_wide))) {
    state <- trans_wide[r, "From / To"]
    idx   <- which(colnames(trans_wide) == state)
    if (length(idx)) {
      val <- trans_wide[r, idx]
      # fix escape: double backslashes for regex
      pattern     <- paste0("\\|\\s*", val, "\\s*\\|")
      replacement <- paste0("| **", val, "** |")
      formatted <- gsub(pattern, replacement, formatted)
    }
  }

  if (!is.null(wave_info)) {
    header <- paste0("### ", wave_info, "\n\n")
    formatted_with_hdr <- paste0(header, formatted)
    return(list(
      table             = formatted,
      table_with_header = formatted_with_hdr,
      wave_info         = wave_info,
      table_name        = table_name
    ))
  }
  list(table = formatted, table_name = table_name)
}

# old function
# margot_transition_table <- function(data, state_var, id_var, wave_var,
#                                     waves = NULL, state_names = NULL,
#                                     table_name = "transition_table") {
#   if (is.null(waves)) {
#     waves <- sort(unique(data[[wave_var]]))
#   }
#   waves <- sort(waves)
#
#   results <- list(tables = list(), waves = list(), table_name = table_name)
#
#   results$explanation <- paste0(
#     "These transition matrices capture shifts in states between consecutive waves. ",
#     "Each cell represents the count of individuals transitioning from one state to another. ",
#     "The rows correspond to the initial state (From), and the columns correspond to the subsequent ",
#     "state (To). **Diagonal entries** (in **bold**) correspond to individuals who remained in ",
#     "the same state. **Off-diagonal entries** correspond to individuals who transitioned to a different state.\n\n",
#     "A higher number on the diagonal relative to off-diagonal entries indicates greater stability in a state. ",
#     "Conversely, higher off-diagonal numbers suggest more frequent shifts between states."
#   )
#
#   results$wave_titles <- function() {
#     sapply(results$waves, function(pair) {
#       paste0("Wave ", pair[1], " → Wave ", pair[2])
#     })
#   }
#
#   for (i in 1:(length(waves) - 1)) {
#     wave1 <- waves[i]
#     wave2 <- waves[i + 1]
#
#     wave_pair_data <- data[data[[wave_var]] %in% c(wave1, wave2), ]
#     temp_data <- data.frame(
#       id = wave_pair_data[[id_var]],
#       wave = wave_pair_data[[wave_var]],
#       state = wave_pair_data[[state_var]]
#     )
#
#     wide_data <- reshape(
#       temp_data,
#       idvar = "id",
#       timevar = "wave",
#       direction = "wide"
#     )
#
#     from_col <- paste0("state.", wave1)
#     to_col <- paste0("state.", wave2)
#
#     valid_rows <- !is.na(wide_data[[from_col]]) & !is.na(wide_data[[to_col]])
#     from_states <- wide_data[valid_rows, from_col]
#     to_states <- wide_data[valid_rows, to_col]
#
#     transition_data <- data.frame(from = from_states, to = to_states)
#     transition_matrix <- table(from = from_states, to = to_states)
#
#     all_states <- sort(unique(c(from_states, to_states)))
#     wave_state_names <- if (is.null(state_names)) paste0("State ", all_states) else state_names
#
#     trans_df <- as.data.frame.matrix(transition_matrix)
#     trans_df$from <- rownames(trans_df)
#     long_trans_df <- tidyr::pivot_longer(trans_df, cols = -from, names_to = "to", values_to = "Freq")
#
#     wave_info <- paste0("Wave ", wave1, " → Wave ", wave2)
#
#     table_result <- transition_table(long_trans_df, wave_state_names,
#                                      wave_info = wave_info,
#                                      table_name = table_name)
#
#     results$tables[[i]] <- table_result$table
#     results$waves[[i]] <- c(wave1, wave2)
#   }
#
#   # Updated quarto_code function using the provided table name
#   results$quarto_code <- function() {
#     code <- paste0("```{r, results='asis'}\ncat(", results$table_name, "$explanation)\n```\n\n")
#
#     for (i in seq_along(results$tables)) {
#       wave1 <- results$waves[[i]][1]
#       wave2 <- results$waves[[i]][2]
#
#       table_code <- paste0(
#         "```{r}\n",
#         "#| label: ", results$table_name, "-wave", wave1, "-wave", wave2, "\n",
#         "#| tbl-cap: \"Transition Matrix From Wave ", wave1, " to Wave ", wave2, "\"\n",
#         results$table_name, "$tables[[", i, "]]\n",
#         "```\n\n"
#       )
#       code <- paste0(code, table_code)
#     }
#
#     cat(code)
#   }
#
#   class(results) <- c("margot_transitions", class(results))
#   return(results)
# }

