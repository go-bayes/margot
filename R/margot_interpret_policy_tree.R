#' Interpret Policy Tree Results
#'
#' This function creates an interpretation of policy tree results from a causal forest or multi-arm causal forest model.
#' It generates a formatted description of the policy tree, including the main splits and recommended actions.
#'
#' @param model A list containing the results from a multi-arm causal forest model.
#' @param model_name A string specifying which model's results to interpret.
#' @param max_depth Integer, 1 or 2; which stored tree to interpret.
#' @param train_proportion Numeric value between 0 and 1 for the proportion of data used for training. Default is 0.5.
#' @param custom_action_names Optional vector of custom names for the actions. Must match the number of actions in the policy tree.
#' @param label_mapping Optional list that maps variable names to custom labels.
#' @param original_df Optional dataframe with untransformed variables, used to display split values on the data scale.
#' @param remove_tx_prefix Logical indicating whether to remove prefixes like t0_ from variable names. Default is TRUE.
#' @param remove_z_suffix Logical indicating whether to remove the _z suffix from variable names. Default is TRUE.
#' @param use_title_case Logical indicating whether to convert variable names to title case. Default is TRUE.
#' @param include_conditional_means Logical indicating whether to include conditional means information if available. Default is TRUE.
#' @param use_math_notation Logical indicating whether to use mathematical notation (E[Y(a)|X]) or plain language. Default is FALSE for clarity.
#' @param output_format Character string specifying output format: "prose" (default) for flowing narrative text, or "bullet" for structured bullet points.
#' @param report_policy_value Character: one of "none" (default), "treat_all",
#'   "control_all", or "both". If not "none", appends policy value summary with
#'   95% confidence intervals based on bootstrap standard errors. Uses test data
#'   stored in `plot_data` and DR scores from the model.
#' @param policy_value_R Integer ≥ 199; number of bootstrap replicates (default 499).
#' @param policy_value_seed Integer or NULL; RNG seed (default 42).
#' @param policy_value_ci_level Numeric confidence level (default 0.95).
#'
#' @return Invisibly returns a string containing the interpretation; also prints it to the console.
#'
#' @importFrom cli cli_alert_info cli_alert_success cli_abort
#' @importFrom glue glue
#' @export
margot_interpret_policy_tree <- function(model,
                                         model_name,
                                         max_depth = 2L,
                                         train_proportion = 0.5,
                                         custom_action_names = NULL,
                                         label_mapping = NULL,
                                         original_df = NULL,
                                         remove_tx_prefix = TRUE,
                                         remove_z_suffix = TRUE,
                                         use_title_case = TRUE,
                                         include_conditional_means = TRUE,
                                         use_math_notation = FALSE,
                                         output_format = c("prose", "bullet"),
                                         report_policy_value = c("none", "treat_all", "control_all", "both", "treated_only"),
                                         policy_value_R = 499L,
                                         policy_value_seed = 42L,
                                         policy_value_ci_level = 0.95) {
  cli::cli_alert_info("Starting policy tree interpretation for {model_name} (depth {max_depth})")

  output_format <- match.arg(output_format)
  report_policy_value <- match.arg(report_policy_value)

  # helper to relabel variables
  transform_var <- function(var) {
    transform_var_name(
      var, label_mapping,
      remove_tx_prefix, remove_z_suffix, use_title_case
    )
  }

  tag <- paste0("policy_tree_depth_", max_depth)
  policy_tree_obj <- model$results[[model_name]][[tag]]
  if (is.null(policy_tree_obj)) {
    cli::cli_abort("No {tag} found for {model_name}")
  }

  # pull action names
  action_names <- policy_tree_obj$action.names
  if (!is.null(custom_action_names)) {
    if (length(custom_action_names) != length(action_names)) {
      cli::cli_abort("Length of custom_action_names must match number of actions")
    }
    action_names <- custom_action_names
    cli::cli_alert_success("Applied custom action names")
  }
  act_labels <- vapply(action_names, transform_var, "")

  # get nodes
  nodes <- policy_tree_obj$nodes
  cols <- policy_tree_obj$columns

  # helper to format split
  format_split <- function(var, val) {
    orig <- get_original_value(var, val, original_df)
    if (!is.null(orig)) {
      glue::glue("{round(val,3)} (original: {orig})")
    } else {
      round(val, 3)
    }
  }

  # general intro
  if (output_format == "prose") {
    intro <- "" # prose format will include intro in the main text
  } else {
    intro <- glue::glue(
      "The policy tree identifies subgroups with different treatment effects by splitting the data based on key variables. ",
      "This analysis used depth-{max_depth} trees with {train_proportion*100}% of the sample for training ",
      "and {(1-train_proportion)*100}% for evaluation.\n\n"
    )
  }
  cli::cli_alert_success("Generated general interpretation")

  if (max_depth == 1L) {
    # single split → two leaves
    n1 <- nodes[[1]]
    var1 <- cols[n1$split_variable]
    sp1 <- format_split(var1, n1$split_value)
    leaf_left <- nodes[[2]]$action
    leaf_right <- nodes[[3]]$action

    if (output_format == "prose") {
      text <- glue::glue(
        "#### Findings for {transform_var(model_name)} at the end of study\n\n",
        "The policy-tree analysis divided the sample on baseline {transform_var(var1)}. ",
        "Respondents who scored ≤ {sp1} formed one branch and were assigned to the {act_labels[leaf_left]} policy. ",
        "Those with baseline {transform_var(var1)} > {sp1} formed the second branch and were assigned to {act_labels[leaf_right]}.\n\n"
      )
    } else {
      text <- glue::glue(
        "**Findings for {transform_var(model_name)} at the end of study:**\n\n",
        "Participants are split on baseline {transform_var(var1)} at {sp1}. ",
        "Those with baseline {transform_var(var1)} ≤ threshold are recommended **{act_labels[leaf_left]}**, ",
        "and those with baseline {transform_var(var1)} > threshold are recommended **{act_labels[leaf_right]}**.\n"
      )
    }
  } else {
    # depth=2 → four leaves
    n1 <- nodes[[1]]
    var1 <- cols[n1$split_variable]
    sp1 <- format_split(var1, n1$split_value)
    n2 <- nodes[[2]]
    var2 <- cols[n2$split_variable]
    sp2 <- format_split(var2, n2$split_value)
    n3 <- nodes[[3]]
    var3 <- cols[n3$split_variable]
    sp3 <- format_split(var3, n3$split_value)
    leaf_22 <- nodes[[4]]$action
    leaf_23 <- nodes[[5]]$action
    leaf_32 <- nodes[[6]]$action
    leaf_33 <- nodes[[7]]$action

    if (output_format == "prose") {
      text <- glue::glue(
        "#### Findings for {transform_var(model_name)} at the end of study\n\n",
        "The policy-tree analysis first divided the sample on baseline {transform_var(var1)}. ",
        "Respondents who scored ≤ {sp1} formed one branch. ",
        "Within this subgroup, a second split occurred on baseline {transform_var(var2)}: ",
        "individuals with baseline {transform_var(var2)} ≤ {sp2} were assigned to the {act_labels[leaf_22]} policy, ",
        "whereas those with baseline {transform_var(var2)} > {sp2} were assigned to {act_labels[leaf_23]}.\n\n",
        "Participants with baseline {transform_var(var1)} scores > {sp1} formed the second major branch. ",
        "In that branch, the tree split on baseline {transform_var(var3)}: ",
        "respondents whose baseline {transform_var(var3)} was ≤ {sp3} were routed to the {act_labels[leaf_32]} policy, ",
        "and those scoring above that threshold were routed to {act_labels[leaf_33]}.\n\n"
      )
    } else {
      text <- glue::glue(
        "**Findings for {transform_var(model_name)} at the end of study:**\n\n",
        "Split 1: baseline {transform_var(var1)} ≤ {sp1}.  ",
        "Within that subgroup, split 2a: baseline {transform_var(var2)} ≤ {sp2}, ",
        "→ **{act_labels[leaf_22]}**; ",
        "baseline {transform_var(var2)} > {sp2} → **{act_labels[leaf_23]}**.\n\n",
        "Split 2: baseline {transform_var(var1)} > {sp1}.  ",
        "Within that subgroup, split 2b: baseline {transform_var(var3)} ≤ {sp3}, ",
        "→ **{act_labels[leaf_32]}**; ",
        "baseline {transform_var(var3)} > {sp3} → **{act_labels[leaf_33]}**.\n"
      )
    }
  }

  # add conditional means interpretation if available
  cond_means_text <- ""
  if (include_conditional_means && !is.null(model$results[[model_name]]$conditional_means)) {
    tryCatch(
      {
        cond_means_text <- compute_conditional_means_interpretation(
          model = model,
          model_name = model_name,
          policy_tree_obj = policy_tree_obj,
          max_depth = max_depth,
          act_labels = act_labels,
          transform_var = transform_var,
          use_math_notation = use_math_notation,
          output_format = output_format,
          original_df = original_df
        )
        if (nzchar(cond_means_text)) {
          cli::cli_alert_success("Added conditional means interpretation")
        }
      },
      error = function(e) {
        cli::cli_alert_warning("Could not compute conditional means interpretation: {e$message}")
        # print more detailed error information
        if (exists("e$call")) {
          cli::cli_alert_info("Error occurred at: {deparse(e$call)}")
        }
        cond_means_text <- "\n\n(Conditional means analysis failed due to an error)\n\n"
      }
    )
  }

  full <- paste0(intro, text, cond_means_text, "\n")

  # Optional: append policy value summary with 95% CIs
  if (report_policy_value != "none" && report_policy_value != "treated_only") {
    try({
      # local compute function (robust to partial sourcing)
      compute_pv <- function(submodel, depth = 2L, R = 499L, seed = NULL, baseline = c("treat_all", "control_all")) {
        baseline <- match.arg(baseline)
        if (!is.null(seed)) set.seed(seed)

        tag <- paste0("policy_tree_depth_", depth)
        pol <- submodel[[tag]]
        if (is.null(pol)) stop("no ", tag, " present for model")

        dr <- submodel$dr_scores
        if (is.null(dr)) dr <- submodel$dr_scores_flipped
        if (is.null(dr)) stop("DR scores missing for policy evaluation")

        pd <- submodel$plot_data
        if (is.null(pd)) stop("plot_data missing; cannot evaluate policy value")
        fullX <- if (!is.null(pd$X_test_full)) pd$X_test_full else pd$X_test
        if (is.null(fullX)) stop("plot_data lacks X_test_full/X_test; cannot evaluate policy value")

        full_df <- as.data.frame(fullX)
        test_idx <- pd$test_indices
        if (is.null(test_idx)) {
          test_idx <- suppressWarnings(as.integer(rownames(full_df)))
        }
        drm <- as.matrix(dr)
        if (!is.null(test_idx) && length(test_idx) == nrow(full_df) && all(!is.na(test_idx)) && max(test_idx) <= nrow(drm)) {
          dr_test <- drm[test_idx, , drop = FALSE]
        } else {
          take <- seq_len(min(nrow(full_df), nrow(drm)))
          dr_test <- drm[take, , drop = FALSE]
          full_df <- full_df[take, , drop = FALSE]
        }

        X <- full_df[, pol$columns, drop = FALSE]
        keep <- stats::complete.cases(X)
        if (!any(keep)) stop("insufficient evaluation data for policy value")
        X <- X[keep, , drop = FALSE]
        dr_eval <- dr_test[keep, , drop = FALSE]
        n <- nrow(X)
        if (n <= 1L) stop("insufficient evaluation data for policy value")

        pick <- function(a, mat) {
          a <- .normalize_policy_actions(a)
          mat[cbind(seq_along(a), a)]
        }

        a_hat <- predict(pol, X)
        if (is.matrix(a_hat)) a_hat <- a_hat[, 1]
        a_hat <- .normalize_policy_actions(a_hat)

        treat_mean <- mean(dr_eval[, 2])
        control_mean <- mean(dr_eval[, 1])
        base_val <- if (baseline == "treat_all") treat_mean else control_mean
        pv_hat <- mean(pick(a_hat, dr_eval)) - base_val

        reps <- replicate(R, {
          idx <- sample.int(n, n, TRUE)
          a_bs <- predict(pol, X[idx, , drop = FALSE])
          if (is.matrix(a_bs)) a_bs <- a_bs[, 1]
          a_bs <- .normalize_policy_actions(a_bs)
          mean(pick(a_bs, dr_eval[idx, , drop = FALSE])) - base_val
        })

        se <- stats::sd(reps)
        z <- stats::qnorm(1 - (1 - policy_value_ci_level) / 2)
        ci_lo <- pv_hat - z * se
        ci_hi <- pv_hat + z * se
        list(estimate = pv_hat, se = se, lo = ci_lo, hi = ci_hi, n = n)
      }

      sm <- model$results[[model_name]]
      add_line <- function(lbl, est) {
        paste0(lbl, ": ", round(est$estimate, 3), " [ ", round(est$lo, 3), ", ", round(est$hi, 3), " ] (n=", est$n, ")")
      }

      lines <- character()
      if (report_policy_value %in% c("treat_all", "both")) {
        val <- compute_pv(sm, depth = max_depth, R = policy_value_R, seed = policy_value_seed, baseline = "treat_all")
        lines <- c(lines, add_line("Policy value vs treat-all", val))
      }
      if (report_policy_value %in% c("control_all", "both")) {
        val <- compute_pv(sm, depth = max_depth, R = policy_value_R, seed = policy_value_seed, baseline = "control_all")
        lines <- c(lines, add_line("Policy value vs control-all", val))
      }

      if (length(lines)) {
        pv_block <- paste0("\n", if (output_format == "prose") "In out-of-sample evaluation, " else "", paste(lines, collapse = "; "), ".\n")
        full <- paste0(full, pv_block)
      }
    }, silent = TRUE)
  }
  cat(full)
  cli::cli_alert_success("Policy tree interpretation completed!")
  invisible(full)
}

#' Compute conditional means interpretation for policy tree leaves
#' @keywords internal
compute_conditional_means_interpretation <- function(model, model_name, policy_tree_obj,
                                                     max_depth, act_labels, transform_var,
                                                     use_math_notation = FALSE,
                                                     output_format = "bullet",
                                                     original_df = NULL) {
  # get conditional means and other needed data
  conditional_means <- model$results[[model_name]]$conditional_means
  # fallback: if conditional means missing, approximate using DR scores on test set
  if (is.null(conditional_means) || nrow(conditional_means) == 0) {
    pd <- model$results[[model_name]]$plot_data
    dr <- model$results[[model_name]]$dr_scores
    if (is.null(dr)) dr <- model$results[[model_name]]$dr_scores_flipped
    if (!is.null(pd) && !is.null(dr)) {
      test_idx <- pd$test_indices
      test_X <- pd$X_test_full
      if (is.null(test_X)) test_X <- pd$X_test
      if (!is.null(test_X)) {
        if (!is.null(test_idx) && length(test_idx) <= nrow(dr)) {
          conditional_means <- dr[test_idx, , drop = FALSE]
        } else {
          test_row_indices <- rownames(test_X)
          if (!is.null(test_row_indices)) {
            idx <- suppressWarnings(as.numeric(test_row_indices))
            if (length(idx) == nrow(test_X) && all(!is.na(idx)) && max(idx) <= nrow(dr)) {
              conditional_means <- dr[idx, , drop = FALSE]
            }
          }
        }
        if (is.null(conditional_means) || nrow(conditional_means) == 0) {
          n_test <- nrow(test_X)
          if (n_test <= nrow(dr)) {
            conditional_means <- dr[seq_len(n_test), , drop = FALSE]
          }
        }
      }
    }
    if (is.null(conditional_means) || nrow(conditional_means) == 0) {
      return("\n\n(Conditional means not available for this model)\n\n")
    }
  }

  # get predictions from plot_data to identify which units fall in which leaf
  plot_data <- model$results[[model_name]]$plot_data
  if (is.null(plot_data) || is.null(plot_data$predictions)) {
    return("\n\n(Policy tree test data not available for conditional means analysis)\n\n")
  }

  test_predictions <- plot_data$predictions
  if (is.matrix(test_predictions)) test_predictions <- test_predictions[, 1]
  test_predictions <- .normalize_policy_actions(test_predictions)

  test_X <- plot_data$X_test_full
  if (is.null(test_X)) {
    test_X <- plot_data$X_test # fallback to restricted covariates
  }
  if (is.null(test_X)) {
    return("\n\n(Policy tree test data not available for conditional means analysis)\n\n")
  }
  test_df <- as.data.frame(test_X)
  test_idx <- plot_data$test_indices
  if (!is.null(test_idx) && length(test_idx) != nrow(test_df)) {
    test_idx <- NULL
  }

  # get covariates for conditional means computation
  covariates <- model$covariates
  if (is.null(covariates)) {
    return("")
  }

  # match test indices to full data indices
  # note: plot_data contains test set only, need to map back
  not_missing <- model$not_missing
  if (is.null(not_missing)) {
    not_missing <- which(complete.cases(covariates))
  }

  n_test <- nrow(test_df)
  if (n_test == 0) {
    return("\n\n(Policy tree test data not available for conditional means analysis)\n\n")
  }

  test_conditional_means <- NULL
  if (nrow(conditional_means) == n_test) {
    test_conditional_means <- conditional_means
  } else {
    if (!is.null(test_idx) && max(test_idx) <= nrow(conditional_means)) {
      test_conditional_means <- conditional_means[test_idx, , drop = FALSE]
    } else {
      test_row_indices <- suppressWarnings(as.integer(rownames(test_df)))
      if (!is.null(test_row_indices) && length(test_row_indices) == n_test && max(test_row_indices) <= nrow(conditional_means)) {
        test_conditional_means <- conditional_means[test_row_indices, , drop = FALSE]
      }
    }
    if (is.null(test_conditional_means)) {
      if (n_test <= nrow(conditional_means)) {
        test_conditional_means <- conditional_means[seq_len(n_test), , drop = FALSE]
      } else {
        return("\n\n(Conditional means analysis not available due to data size mismatch)\n\n")
      }
    }
  }

  if (output_format == "prose") {
    text <- "\n#### Treatment-effect heterogeneity\n\n"

    if (max_depth == 2L) {
      text <- paste0(
        text,
        "A depth-two policy tree therefore produced four terminal leaves. ",
        "Conditional average treatment effects (CATEs) were estimated within each leaf:\n\n"
      )
    } else {
      text <- paste0(
        text,
        "The policy tree produced two terminal leaves. ",
        "Conditional average treatment effects (CATEs) were estimated within each leaf:\n\n"
      )
    }
  } else {
    text <- "\n\n**Treatment Effect Heterogeneity**\n\n"

    # Add description based on notation preference
    if (use_math_notation) {
      text <- paste0(
        text,
        "The following table shows conditional mean outcomes E[Y(a)|X∈leaf] for each treatment arm a∈{0,1}, ",
        "where Y(a) denotes the potential outcome under treatment a. ",
        "The conditional average treatment effect (CATE) is τ(x) = E[Y(1)|X∈leaf] - E[Y(0)|X∈leaf].\n\n"
      )
    } else {
      text <- paste0(
        text,
        "The following analysis shows how treatment effects vary across different subgroups identified by the policy tree.\n\n"
      )
    }
  }

  if (max_depth == 1L) {
    # two leaves for depth-1 tree
    nodes <- policy_tree_obj$nodes

    # leaf assignments based on first split
    var1 <- policy_tree_obj$columns[nodes[[1]]$split_variable]
    split1 <- nodes[[1]]$split_value

    # identify units in each leaf using the test data
    if (var1 %in% colnames(test_df)) {
      left_leaf_idx <- which(test_df[, var1] <= split1)
      right_leaf_idx <- which(test_df[, var1] > split1)

      # compute average conditional means for each leaf
      result_text <- compute_leaf_means(
        leaf_idx = list(left = left_leaf_idx, right = right_leaf_idx),
        predictions = test_predictions,
        conditional_means = test_conditional_means,
        act_labels = act_labels,
        leaf_names = c(
          paste0("baseline ", transform_var(var1), " ≤ ", round(split1, 3)),
          paste0("baseline ", transform_var(var1), " > ", round(split1, 3))
        ),
        use_math_notation = use_math_notation,
        output_format = output_format,
        original_df = original_df,
        model_name = model_name
      )
      text <- paste0(text, result_text)

      # add overall statistics for depth-1
      tryCatch(
        {
          n_total <- length(test_predictions)
          if (n_total > 0) {
            n_control <- sum(test_predictions == 1)
            n_treatment <- sum(test_predictions == 2)
            pct_control <- round(100 * n_control / n_total, 1)
            pct_treatment <- round(100 * n_treatment / n_total, 1)

            if (output_format == "prose") {
              text <- paste0(
                text,
                "\n#### Overall policy performance\n\n",
                "Across the full test set (N = ", formatC(n_total, format = "d", big.mark = ","), "), ",
                "the policy prescribes ", tolower(act_labels[1]), " for ",
                formatC(n_control, format = "d", big.mark = ","), " participants (", pct_control, "%) ",
                "and ", tolower(act_labels[2]), " for ",
                formatC(n_treatment, format = "d", big.mark = ","), " participants (", pct_treatment, "%).\n"
              )
            } else {
              text <- paste0(
                text,
                "\n**Summary Statistics**\n\n",
                "Total units in test set: n = ", n_total, "\n",
                "Units assigned to ", act_labels[1], ": ", n_control, " (", pct_control, "%)\n",
                "Units assigned to ", act_labels[2], ": ", n_treatment, " (", pct_treatment, "%)\n\n"
              )
            }
          }
        },
        error = function(e) {
          # fail silently
        }
      )
    }
  } else {
    # four leaves for depth-2 tree
    text <- paste0(
      text, "Policy tree has four leaves. Conditional mean analysis for depth-2 trees ",
      "shows treatment effects within each subgroup defined by the two-level splits.\n\n"
    )

    # extract nodes for depth-2 tree
    nodes <- policy_tree_obj$nodes

    # first split
    var1 <- policy_tree_obj$columns[nodes[[1]]$split_variable]
    split1 <- nodes[[1]]$split_value

    # second level splits
    var2 <- policy_tree_obj$columns[nodes[[2]]$split_variable]
    split2 <- nodes[[2]]$split_value
    var3 <- policy_tree_obj$columns[nodes[[3]]$split_variable]
    split3 <- nodes[[3]]$split_value

    # identify units in each leaf using the test data
    if (all(c(var1, var2, var3) %in% colnames(test_df))) {
      # define the four leaves based on the tree structure
      # leaf 1: var1 <= split1 & var2 <= split2
      # leaf 2: var1 <= split1 & var2 > split2
      # leaf 3: var1 > split1 & var3 <= split3
      # leaf 4: var1 > split1 & var3 > split3

      left_idx <- which(test_df[, var1] <= split1)
      right_idx <- which(test_df[, var1] > split1)

      # ensure we have valid indices before subsetting
      if (length(left_idx) > 0) {
        left_var2_vals <- test_df[left_idx, var2]
        leaf1_idx <- left_idx[left_var2_vals <= split2]
        leaf2_idx <- left_idx[left_var2_vals > split2]
      } else {
        leaf1_idx <- integer(0)
        leaf2_idx <- integer(0)
      }

      if (length(right_idx) > 0) {
        right_var3_vals <- test_df[right_idx, var3]
        leaf3_idx <- right_idx[right_var3_vals <= split3]
        leaf4_idx <- right_idx[right_var3_vals > split3]
      } else {
        leaf3_idx <- integer(0)
        leaf4_idx <- integer(0)
      }

      # compute average conditional means for each leaf
      leaf_indices <- list(leaf1_idx, leaf2_idx, leaf3_idx, leaf4_idx)
      leaf_names <- c(
        paste0(
          "baseline ", transform_var(var1), " ≤ ", round(split1, 3), " & baseline ",
          transform_var(var2), " ≤ ", round(split2, 3)
        ),
        paste0(
          "baseline ", transform_var(var1), " ≤ ", round(split1, 3), " & baseline ",
          transform_var(var2), " > ", round(split2, 3)
        ),
        paste0(
          "baseline ", transform_var(var1), " > ", round(split1, 3), " & baseline ",
          transform_var(var3), " ≤ ", round(split3, 3)
        ),
        paste0(
          "baseline ", transform_var(var1), " > ", round(split1, 3), " & baseline ",
          transform_var(var3), " > ", round(split3, 3)
        )
      )

      result_text <- compute_leaf_means(
        leaf_idx = leaf_indices,
        predictions = test_predictions,
        conditional_means = test_conditional_means,
        act_labels = act_labels,
        leaf_names = leaf_names,
        use_math_notation = use_math_notation,
        output_format = output_format,
        original_df = original_df,
        model_name = model_name
      )
      text <- paste0(text, result_text)

      # add overall statistics
      tryCatch(
        {
          n_control <- sum(test_predictions == 1) # assuming 1 = control, 2 = treatment
          n_treatment <- sum(test_predictions == 2)
          n_total <- length(test_predictions)

          if (n_total > 0) {
            pct_control <- round(100 * n_control / n_total, 1)
            pct_treatment <- round(100 * n_treatment / n_total, 1)


            # Calculate summary statistics per leaf
            effects <- numeric()          # treat - control per leaf
            sizes <- numeric()            # leaf sizes
            leaf_action <- integer()      # 1 = control, 2 = treatment
            leaf_treat_avg <- numeric()   # mean under treatment in leaf
            leaf_ctrl_avg  <- numeric()   # mean under control in leaf
            for (j in seq_along(leaf_indices)) {
              if (length(leaf_indices[[j]]) > 0) {
                leaf_cm <- test_conditional_means[leaf_indices[[j]], , drop = FALSE]
                if (nrow(leaf_cm) > 0 && ncol(leaf_cm) == 2) {
                  avg_cm <- colMeans(leaf_cm, na.rm = TRUE)
                  eff <- avg_cm[2] - avg_cm[1]
                  effects <- c(effects, eff)
                  sizes <- c(sizes, length(leaf_indices[[j]]))
                  # infer action from predictions in this leaf (all should be identical)
                  act <- unique(test_predictions[leaf_indices[[j]]])
                  leaf_action <- c(leaf_action, if (length(act)) act[1] else NA_integer_)
                  leaf_ctrl_avg <- c(leaf_ctrl_avg, avg_cm[1])
                  leaf_treat_avg <- c(leaf_treat_avg, avg_cm[2])
                }
              }
            }

            # Policy gains relative to baselines using conditional means
            weighted_avg_effect <- if (length(effects) > 0 && sum(sizes) > 0) sum(effects * sizes) / sum(sizes) else NA
            policy_gain_vs_control <- if (length(effects) > 0 && sum(sizes) > 0) {
              # sum over leaves recommended to treat of (treat - control) * size / N
              treat_mask <- leaf_action == 2
              sum(effects[treat_mask] * sizes[treat_mask]) / sum(sizes)
            } else NA
            policy_gain_vs_treat <- if (length(effects) > 0 && sum(sizes) > 0) {
              # sum over leaves recommended to control of (control - treat) * size / N
              ctrl_mask <- leaf_action == 1
              sum((-effects[ctrl_mask]) * sizes[ctrl_mask]) / sum(sizes)
            } else NA
            avg_uplift_among_treated <- if (length(effects) > 0 && sum(sizes[leaf_action == 2], na.rm = TRUE) > 0) {
              sum(effects[leaf_action == 2] * sizes[leaf_action == 2], na.rm = TRUE) / sum(sizes[leaf_action == 2], na.rm = TRUE)
            } else NA

            # Bootstrap CI for avg uplift among treated using test predictions + conditional means
            avg_uplift_lo <- avg_uplift_hi <- NA_real_
            if (!is.na(avg_uplift_among_treated) && nrow(test_conditional_means) > 1) {
              n_eval <- nrow(test_conditional_means)
              # align lengths; assume test_predictions correspond to rows in test_conditional_means
              tm_vec <- (test_predictions[seq_len(n_eval)] == 2)
              reps_t <- replicate(policy_value_R, {
                idx <- sample.int(n_eval, n_eval, TRUE)
                tm_bs <- tm_vec[idx]
                if (any(tm_bs)) {
                  cm_bs <- test_conditional_means[idx, , drop = FALSE]
                  mean(cm_bs[tm_bs, 2] - cm_bs[tm_bs, 1])
                } else NA_real_
              })
              reps_t <- reps_t[!is.na(reps_t)]
              if (length(reps_t) > 1) {
                se_t <- stats::sd(reps_t)
                zval <- stats::qnorm(1 - (1 - policy_value_ci_level) / 2)
                avg_uplift_lo <- avg_uplift_among_treated - zval * se_t
                avg_uplift_hi <- avg_uplift_among_treated + zval * se_t
              }
            }

            if (output_format == "prose") {
              text <- paste0(
                text,
                "\n#### Overall policy performance\n\n",
                "Across the full test set (N = ", formatC(n_total, format = "d", big.mark = ","), "), ",
                "the policy prescribes ", tolower(act_labels[1]), " for ",
                formatC(n_control, format = "d", big.mark = ","), " participants (", pct_control, "%) ",
                "and ", tolower(act_labels[2]), " for ",
                formatC(n_treatment, format = "d", big.mark = ","), " participants (", pct_treatment, "%). "
              )

              if (!is.na(policy_gain_vs_control) || !is.na(policy_gain_vs_treat) || !is.na(avg_uplift_among_treated)) {
                # Optionally transform to original scale for policy_gain_vs_control
                original_scale_overall <- ""

                # Get transformation info if available
                transform_info <- NULL
                if (!is.null(original_df) && !is.null(model_name)) {
                  transform_info <- get_outcome_transformation_info(model_name, original_df)
                }

                if (!is.null(transform_info)) {
                  if (transform_info$has_z && !transform_info$has_log && !is.na(policy_gain_vs_control)) {
                    # simple z-transformation: multiply by SD for control baseline gain
                    policy_gain_display <- policy_gain_vs_control * transform_info$orig_sd
                    original_scale_overall <- paste0(" (original scale: ", format_minimal_decimals(policy_gain_display), " units)")
                  } else if (transform_info$has_z && transform_info$has_log && !is.na(policy_gain_vs_control)) {
                    # log+z transformation: use multiplicative interpretation
                    units_info <- detect_variable_units(transform_info$original_var)

                    # calculate effect on log scale
                    delta_log_overall <- policy_gain_vs_control * transform_info$log_sd
                    ratio_overall <- exp(delta_log_overall)
                    pct_change_overall <- (ratio_overall - 1) * 100
                    change_word <- if (pct_change_overall >= 0) "increase" else "decrease"

                    # calculate absolute change based on population mean
                    # use display mean if available (for corrected population statistics)
                    log_mean_overall <- if (!is.null(transform_info$use_display_mean) && transform_info$use_display_mean) {
                      transform_info$log_mean_display
                    } else {
                      transform_info$log_mean
                    }
                    pop_mean_overall <- exp(log_mean_overall) - transform_info$log_offset
                    if (!is.null(units_info$scale_factor)) {
                      pop_mean_overall <- pop_mean_overall * units_info$scale_factor
                    }
                    abs_change_overall <- pop_mean_overall * (ratio_overall - 1)

                    # format based on unit type
                    if (units_info$type == "monetary") {
                      original_scale_overall <- sprintf(
                        " (%s%s average %s)",
                        units_info$symbol, format_minimal_decimals(abs(abs_change_overall)),
                        change_word
                      )
                    } else if (units_info$type == "time") {
                      original_scale_overall <- sprintf(
                        " (%s %s average %s)",
                        format_minimal_decimals(abs(abs_change_overall)),
                        units_info$name,
                        change_word
                      )
                    } else {
                      # for other types, don't show original scale
                      original_scale_overall <- ""
                    }
                  }
                }

                # Report policy values relative to both baselines (rounded to 3 d.p.)
                pv_lines <- character()
                if (report_policy_value %in% c("both", "control_all") && !is.na(policy_gain_vs_control)) {
                  pv_lines <- c(pv_lines, paste0(
                    "Policy value vs control-all: ", round(policy_gain_vs_control, 3),
                    if (nchar(original_scale_overall) > 0) paste0(" ", original_scale_overall) else ""
                  ))
                }
                if (report_policy_value %in% c("both", "treat_all") && !is.na(policy_gain_vs_treat)) {
                  pv_lines <- c(pv_lines, paste0(
                    "Policy value vs treat-all: ", round(policy_gain_vs_treat, 3)
                  ))
                }
                if (report_policy_value %in% c("treated_only", "both") && !is.na(avg_uplift_among_treated)) {
                  uplift_line <- paste0("Avg uplift among treated: ", round(avg_uplift_among_treated, 3))
                  if (!is.na(avg_uplift_lo) && !is.na(avg_uplift_hi)) {
                    uplift_line <- paste0(uplift_line, " [ ", round(avg_uplift_lo, 3), ", ", round(avg_uplift_hi, 3), " ]")
                  }
                  pv_lines <- c(pv_lines, uplift_line)
                }
                if (length(pv_lines)) {
                  text <- paste0(text, paste(pv_lines, collapse = "; "), ".\n")
                }
              }
            } else {
              text <- paste0(
                text,
                "\n**Summary Statistics**\n\n",
                "Total units in test set: n = ", n_total, "\n",
                "Units assigned to ", act_labels[1], ": ", n_control, " (", pct_control, "%)\n",
                "Units assigned to ", act_labels[2], ": ", n_treatment, " (", pct_treatment, "%)\n"
              )

              if (!is.na(weighted_avg_effect)) {
                # Transform to original scale if possible
                original_scale_overall <- ""

                # Get transformation info if available
                transform_info <- NULL
                if (!is.null(original_df) && !is.null(model_name)) {
                  transform_info <- get_outcome_transformation_info(model_name, original_df)
                }

                if (!is.null(transform_info)) {
                  if (transform_info$has_z && !transform_info$has_log) {
                    # simple z-transformation: multiply by SD
                    weighted_avg_display <- weighted_avg_effect * transform_info$orig_sd
                    original_scale_overall <- paste0(" (original scale: ", format_minimal_decimals(weighted_avg_display), " units)")
                  } else if (transform_info$has_z && transform_info$has_log) {
                    # log+z transformation: use multiplicative interpretation
                    units_info <- detect_variable_units(transform_info$original_var)

                    # calculate effect on log scale
                    delta_log_overall <- weighted_avg_effect * transform_info$log_sd
                    ratio_overall <- exp(delta_log_overall)
                    pct_change_overall <- (ratio_overall - 1) * 100
                    change_word <- if (pct_change_overall >= 0) "increase" else "decrease"

                    # calculate absolute change based on population mean
                    # use display mean if available (for corrected population statistics)
                    log_mean_overall <- if (!is.null(transform_info$use_display_mean) && transform_info$use_display_mean) {
                      transform_info$log_mean_display
                    } else {
                      transform_info$log_mean
                    }
                    pop_mean_overall <- exp(log_mean_overall) - transform_info$log_offset
                    if (!is.null(units_info$scale_factor)) {
                      pop_mean_overall <- pop_mean_overall * units_info$scale_factor
                    }
                    abs_change_overall <- pop_mean_overall * (ratio_overall - 1)

                    # format based on unit type
                    if (units_info$type == "monetary") {
                      original_scale_overall <- sprintf(
                        " (%s%s average %s)",
                        units_info$symbol, format_minimal_decimals(abs(abs_change_overall)),
                        change_word
                      )
                    } else if (units_info$type == "time") {
                      original_scale_overall <- sprintf(
                        " (%s %s average %s)",
                        format_minimal_decimals(abs(abs_change_overall)),
                        units_info$name,
                        change_word
                      )
                    } else {
                      # for other types, don't show original scale
                      original_scale_overall <- ""
                    }
                  }
                }

                text <- paste0(
                  text,
                  "Weighted average treatment effect: ", format_minimal_decimals(weighted_avg_effect), original_scale_overall, "\n"
                )
              }

              text <- paste0(text, "\n")
            }
          }
        },
        error = function(e) {
          # fail silently
        }
      )
    } else {
      # fallback to simple summary if we can't compute leaf means
      tryCatch(
        {
          n_control <- sum(test_predictions == 1)
          n_treatment <- sum(test_predictions == 2)

          if (n_control > 0 && n_treatment > 0) {
            text <- paste0(
              text,
              "Among the test set:\n",
              "- ", n_control, " units were assigned to ", act_labels[1], "\n",
              "- ", n_treatment, " units were assigned to ", act_labels[2], "\n\n",
              "(Detailed leaf analysis not available due to missing covariate data)\n\n"
            )
          }
        },
        error = function(e) {
          # fail silently
        }
      )
    }
  }

  return(text)
}

#' Compute average conditional means within leaves
#' @keywords internal
compute_leaf_means <- function(leaf_idx, predictions, conditional_means, act_labels, leaf_names,
                               use_math_notation = FALSE, output_format = "bullet",
                               original_df = NULL, model_name = NULL, display_original_scale = TRUE) {
  text <- ""

  # get transformation info if available
  transform_info <- NULL
  if (display_original_scale && !is.null(original_df) && !is.null(model_name)) {
    transform_info <- get_outcome_transformation_info(model_name, original_df)
  }

  # handle both list and non-list inputs
  if (!is.list(leaf_idx)) {
    leaf_idx <- list(leaf_idx)
  }

  for (i in seq_along(leaf_idx)) {
    idx <- leaf_idx[[i]]
    if (length(idx) == 0) next

    # get the conditional means for units in this leaf
    leaf_cm <- conditional_means[idx, , drop = FALSE]
    if (nrow(leaf_cm) == 0) next

    # compute average conditional means
    avg_cm <- colMeans(leaf_cm, na.rm = TRUE)

    # get predominant action in this leaf
    leaf_preds <- predictions[idx]
    if (length(leaf_preds) == 0) next

    pred_table <- table(leaf_preds)
    if (length(pred_table) == 0) next

    # ensure we have valid action indices
    pred_names <- names(sort(pred_table, decreasing = TRUE))
    if (length(pred_names) == 0) next

    predominant_action <- as.integer(pred_names[1])
    if (is.na(predominant_action) || predominant_action < 1 || predominant_action > length(act_labels)) {
      predominant_action <- 1 # default to first action
    }

    # compute proportion assigned to each treatment
    prop_control <- sum(leaf_preds == 1) / length(leaf_preds)
    prop_treat <- sum(leaf_preds == 2) / length(leaf_preds)

    # compute treatment effect (difference in conditional means)
    if (length(avg_cm) == 2) {
      treatment_effect <- avg_cm[2] - avg_cm[1]

      # transform to original scale if possible
      treatment_effect_display <- NULL
      original_scale_text <- ""
      if (!is.null(transform_info)) {
        if (transform_info$has_z && !transform_info$has_log) {
          # simple z-transformation: multiply by SD
          treatment_effect_display <- treatment_effect * transform_info$orig_sd
          original_scale_text <- paste0(" (original scale: ", format_minimal_decimals(treatment_effect_display), " units)")
        } else if (transform_info$has_z && transform_info$has_log) {
          # log+z transformation: use multiplicative interpretation
          # detect units
          units_info <- detect_variable_units(transform_info$original_var)

          # calculate the effect on the log scale
          delta_log <- treatment_effect * transform_info$log_sd

          # get multiplicative effect
          ratio <- exp(delta_log)

          # calculate percentage change
          pct_change <- (ratio - 1) * 100

          # calculate mean on original scale for absolute change
          # use display mean if available (for corrected population statistics)
          log_mean_to_use <- if (!is.null(transform_info$use_display_mean) && transform_info$use_display_mean) {
            transform_info$log_mean_display
          } else {
            transform_info$log_mean
          }
          pop_mean_orig <- exp(log_mean_to_use) - transform_info$log_offset

          # apply scale factor if needed (e.g., hours to minutes)
          if (!is.null(units_info$scale_factor)) {
            pop_mean_orig <- pop_mean_orig * units_info$scale_factor
          }

          # calculate absolute change
          abs_change <- pop_mean_orig * (ratio - 1)

          # format based on unit type
          change_word <- if (pct_change >= 0) "increase" else "decrease"
          abs_pct_change <- abs(pct_change)

          if (units_info$type == "monetary") {
            original_scale_text <- sprintf(
              " (%s%s average %s)",
              units_info$symbol, format_minimal_decimals(abs(abs_change)),
              change_word
            )
          } else if (units_info$type == "time") {
            original_scale_text <- sprintf(
              " (%s %s average %s)",
              format_minimal_decimals(abs(abs_change)),
              units_info$name,
              change_word
            )
          } else {
            # generic format for other types - just show standardized effect
            original_scale_text <- ""
          }
        }
      }

      if (output_format == "prose") {
        # prose format for flowing text
        pct_assigned <- round(100 * max(prop_control, prop_treat), 1)
        pct_of_test <- round(100 * length(idx) / length(predictions), 1)

        # determine if everyone or partial assignment
        assignment_text <- if (pct_assigned == 100) {
          paste0("every participant in this group was recommended ", tolower(act_labels[predominant_action]))
        } else {
          paste0(pct_assigned, "% were recommended ", tolower(act_labels[predominant_action]))
        }

        text <- paste0(
          text,
          "• **Leaf ", i, "—", tolower(leaf_names[i]), "** ",
          "(n = ", formatC(length(idx), format = "d", big.mark = ","), "; ", pct_of_test, "% of the test set): ",
          assignment_text, ". "
        )

        # add outcomes with minimal decimals
        text <- paste0(
          text,
          "The mean outcome under control was ", format_minimal_decimals(avg_cm[1]), ", ",
          "the mean under treatment was ", format_minimal_decimals(avg_cm[2]), ", ",
          "yielding a CATE of ", format_minimal_decimals(treatment_effect), original_scale_text, ".\n\n"
        )
      } else if (use_math_notation) {
        text <- paste0(
          text,
          "**Leaf ", i, " (", leaf_names[i], ")**\n",
          "n = ", length(idx), "; ",
          "assigned treatment: ", act_labels[predominant_action], " (",
          round(100 * max(prop_control, prop_treat), 1), "%)\n\n",
          "E[Y(0)|X∈leaf] = ", format_minimal_decimals(avg_cm[1]), "\n",
          "E[Y(1)|X∈leaf] = ", format_minimal_decimals(avg_cm[2]), "\n",
          "CATE = ", format_minimal_decimals(treatment_effect), original_scale_text, "\n\n"
        )
      } else {
        # clear, simple format
        text <- paste0(
          text,
          "**Leaf ", i, " (", leaf_names[i], ")**\n",
          "Sample size: ", length(idx), " (", round(100 * length(idx) / length(predictions), 1), "% of test set)\n",
          "Recommended treatment: ", act_labels[predominant_action], " (",
          round(100 * max(prop_control, prop_treat), 1), "% of this group)\n\n",
          "Control outcome: ", format_minimal_decimals(avg_cm[1]), "\n",
          "Treatment outcome: ", format_minimal_decimals(avg_cm[2]), "\n",
          "Treatment effect (CATE): ", format_minimal_decimals(treatment_effect), original_scale_text, "\n"
        )

        text <- paste0(text, "\n")
      }
    }
  }

  return(text)
}
