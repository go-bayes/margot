#' Create Combined Tables for Subset Condition Using GRF Models
#'
#' This function calculates new evaluation tables for specified outcome variables
#' using a subset condition, and combines them into a single data frame. It uses
#' the models generated by `model_grf_causal_forest` or similar functions to create these tables.
#'
#' @param model_results A list of model results from `model_grf_causal_forest` or similar functions.
#'        Note that these functions should be called with `save_models = TRUE`.
#' @param outcome_vars Optional. A character vector of outcome variable names. If NULL,
#'        the function will use all models in the input.
#' @param subset_condition A logical vector indicating the subset of data to use. Default is NULL.
#' @param scale A character string indicating the scale to use in `margot_model_evalue`. Default is "RD".
#' @param debug Logical. If TRUE, print debug information. Default is FALSE.
#'
#' @return A data frame combining all custom evaluation tables for the specified subset condition.
#'
#' @details
#' The function uses `margot_model_evalue` to calculate evaluation metrics for each model
#' in the subset of data specified by `subset_condition`. If outcome_vars is not provided,
#' it will use all models in the input. The function can handle models with or without the "model_" prefix.
#'
#' @note
#' Ensure that the `model_results` list contains full model objects for all specified `outcome_vars`.
#' This requires setting `save_models = TRUE` when calling the original GRF model function.
#'
#' @seealso
#' \code{\link{model_grf_causal_forest}} for generating the initial models.
#'
#' @importFrom margot margot_model_evalue
#'
#' @examples
#' \dontrun{
#' # Assuming result_outcomes_social_test is your results object from model_grf_causal_forest
#' subset_condition <- X_toy[, "t0_self_esteem_z"] < 0
#' result_subset <- margot_grf_subset_table(
#'   model_results = result_outcomes_social_test,
#'   outcome_vars = outcomes_social,
#'   subset_condition = subset_condition,
#'   scale = "RD"
#' )
#' print(result_subset)
#' }
#'
#' @export
margot_grf_subset_table <- function(model_results, outcome_vars = NULL, subset_condition = NULL, scale = "RD", debug = FALSE) {
  if (debug) cat("Debug: class of subset_condition:", class(subset_condition), "\n")
  if (debug) cat("Debug: length of subset_condition:", length(subset_condition), "\n")

  if (is.null(outcome_vars)) {
    outcome_vars <- gsub("^model_", "", names(model_results$full_models))
    if (debug) cat("Debug: outcome_vars set to:", paste(outcome_vars, collapse=", "), "\n")
  }

  tables <- list()
  for (outcome in outcome_vars) {
    if (debug) cat("Debug: Processing outcome:", outcome, "\n")
    model_name <- paste0("model_", outcome)
    if (model_name %in% names(model_results$full_models)) {
      model <- model_results$full_models[[model_name]]
      if (debug) {
        cat("Debug: Model class:", class(model), "\n")
        cat("Debug: Model names:", paste(names(model), collapse=", "), "\n")
      }

      tryCatch({
        custom_table <- margot::margot_model_evalue(model, scale = scale, new_name = outcome, subset = subset_condition)
        tables[[outcome]] <- custom_table
        if (debug) cat("Debug: Successfully created table for", outcome, "\n")
      }, error = function(e) {
        if (debug) cat("Debug: Error in margot_model_evalue for", outcome, ":", e$message, "\n")
      })
    } else {
      if (debug) cat("Debug: Model for outcome", outcome, "not found in the input models.\n")
    }
  }

  if (length(tables) == 0) {
    if (debug) cat("Debug: No tables were created.\n")
    return(NULL)
  }

  combined_table <- do.call(rbind, tables)
  return(combined_table)
}
