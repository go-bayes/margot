% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/margot_interpret_heterogeneity.R
\name{margot_interpret_heterogeneity}
\alias{margot_interpret_heterogeneity}
\title{Interpret Heterogeneity Evidence from Multiple Sources}
\usage{
margot_interpret_heterogeneity(
  models = NULL,
  model_names = NULL,
  spend_levels = c(0.1, 0.4),
  require_any_positive = TRUE,
  exclude_negative_any = TRUE,
  require_omnibus = FALSE,
  alpha = 0.05,
  adjust = "none",
  flipped_outcomes = NULL,
  label_mapping = NULL,
  verbose = TRUE,
  include_extended_report = TRUE,
  rate_results = NULL,
  qini_results = NULL,
  omnibus_results = NULL,
  use_cross_validation = TRUE,
  cv_num_folds = 5,
  cv_results = NULL,
  seed = 12345,
  parallel = FALSE,
  n_cores = future::availableCores() - 1
)
}
\arguments{
\item{models}{Output from `margot_causal_forest()` containing model results}

\item{model_names}{Character vector of model names to analyse. If NULL (default), 
analyses all models. Model names can be specified with or without "model_" prefix.}

\item{spend_levels}{Numeric vector of spend levels for QINI analysis. 
Default is c(0.1, 0.4).}

\item{require_any_positive}{Logical. If TRUE (default), include models that 
show positive evidence in ANY method. If FALSE, require positive evidence 
in ALL methods.}

\item{exclude_negative_any}{Logical. If TRUE (default), exclude models that 
show negative evidence in ANY RATE test (AUTOC or QINI). Models with any 
negative RATE evidence are classified as "excluded_negative_rate" and will 
not appear in selected or exploratory lists.}

\item{require_omnibus}{Logical. If TRUE, only include models that pass the 
omnibus calibration test. Default is FALSE.}

\item{alpha}{Numeric. Significance level for RATE tests. Default is 0.05.
Note: this controls which RATE estimates are considered statistically significant after
multiple testing correction.}

\item{adjust}{Character. Multiple testing adjustment method for RATE estimates. 
Options include "BH" (Benjamini-Hochberg), "BY" (Benjamini-Yekutieli), 
"bonferroni", "holm", "fdr", or "none". Default is "none".
Note: When use_cross_validation = TRUE (the default), only "bonferroni" or "none" are valid.
Invalid methods will be automatically converted to "none" without warning.}

\item{flipped_outcomes}{Character vector of outcome names that were flipped 
(reversed) in preprocessing. Used for interpretation text.}

\item{label_mapping}{Named list for mapping model names to human-readable labels.}

\item{verbose}{Logical. If TRUE, show progress messages. Default is TRUE.}

\item{include_extended_report}{Logical. If TRUE (default), generate detailed academic-style report
with full statistics and confidence intervals.}

\item{rate_results}{Optional pre-computed RATE results to skip computation.}

\item{qini_results}{Optional pre-computed QINI results to skip computation.}

\item{omnibus_results}{Optional pre-computed omnibus test results to skip computation.}

\item{use_cross_validation}{Logical. If TRUE (default), use cross-validation for RATE tests
instead of standard approach. This provides confidence intervals through robust inference.}

\item{cv_num_folds}{Integer. Number of CV folds when use_cross_validation = TRUE (default 5).}

\item{cv_results}{Optional pre-computed CV results to skip computation.}

\item{seed}{Integer. Random seed for reproducibility in all computations (default 12345).}

\item{parallel}{Logical. Use parallel processing for cross-validation when use_cross_validation = TRUE 
(default FALSE). Note: Parallel processing is experimental and may encounter memory issues.}

\item{n_cores}{Integer. Number of cores for parallel processing when parallel = TRUE 
(default all cores - 1). Only applies when use_cross_validation = TRUE.}
}
\value{
A list containing:
  \item{selected_model_ids}{Character vector of model IDs with heterogeneity evidence}
  \item{selected_model_names}{Character vector of human-readable model names}
  \item{exploratory_model_ids}{Character vector of model IDs with exploratory evidence (positive calibration or QINI curve, no negative RATE)}
  \item{exploratory_model_names}{Character vector of human-readable model names with exploratory evidence}
  \item{all_selected_model_ids}{Combined vector of selected_model_ids and exploratory_model_ids}
  \item{all_selected_model_names}{Combined vector of selected_model_names and exploratory_model_names}
  \item{excluded_model_ids}{Character vector of model IDs to exclude}
  \item{excluded_model_names}{Character vector of human-readable excluded model names}
  \item{evidence_summary}{Data frame with detailed evidence by source. Contains columns: model_id, model_name, category (selected/excluded/unclear), mean_prediction_test (calibration status), differential_prediction_test (heterogeneity test), rate_autoc, rate_qini, qini_curve, positive_count (backwards compatibility: same as rate_positive_count), negative_count (backwards compatibility: same as rate_negative_count), rate_positive_count (positive RATE tests only), rate_negative_count (negative RATE tests only), total_positive_count (across all 4 tests), total_negative_count (across all 4 tests), is_excluded (1 if any negative RATE test), strict_inclusion_count (positive RATE tests only if no negative RATE), selection_source (excluded/rate_only/qini_curve_only/both_rate_and_qini/none), has_negative_rate, has_positive_rate, has_positive_qini_curve. Note: mean_prediction_test indicates calibration quality but is not included in heterogeneity scoring}
  \item{interpretation}{Character string with main interpretation text organized by evidence categories}
  \item{summary}{Character string with brief summary}
  \item{recommendations}{Character string with actionable recommendations}
  \item{rate_results}{List containing AUTOC and QINI RATE results, interpretation, and raw_results from margot_rate() or margot_rate_cv()}
  \item{qini_results}{QINI curve interpretation results}
  \item{omnibus_results}{Omnibus calibration test results}
  \item{concordance}{List analysing agreement between methods}
  \item{extended_report}{Character string with detailed academic report (if include_extended_report = TRUE)}
  \item{cv_results}{Cross-validation results object (if use_cross_validation = TRUE) that can be passed to margot_plot_cv_results() and margot_plot_cv_summary()}
  \item{method_used}{Character string indicating whether "cross_validation" or "standard" method was used}
}
\description{
Combines evidence from multiple heterogeneity tests (RATE AUTOC, RATE QINI, 
QINI curves, and omnibus calibration tests) to provide unified recommendations 
about which models show treatment effect heterogeneity.
}
\examples{
\dontrun{
# Simple usage - let the function handle everything
het_evidence <- margot_interpret_heterogeneity(
  models = causal_forest_results,
  spend_levels = c(0.1, 0.4),
  flipped_outcomes = c("anxiety", "depression")
)

# Analyze specific models only
het_evidence_subset <- margot_interpret_heterogeneity(
  models = causal_forest_results,
  model_names = c("t2_depression_z", "t2_anxiety_z"),
  spend_levels = c(0.1, 0.4)
)

# View interpretation
cat(het_evidence$interpretation)

# Use selected models for targeting
policy_results <- margot_policy(
  causal_forest_results,
  model_names = het_evidence$selected_model_ids
)

# Use model_names parameter with selected models
het_focused <- margot_interpret_heterogeneity(
  models = causal_forest_results,
  model_names = het_evidence$selected_model_ids,
  include_extended_report = TRUE
)

# Advanced usage with pre-computed results
het_evidence <- margot_interpret_heterogeneity(
  models = causal_forest_results,
  rate_results = my_rate_results,
  require_omnibus = TRUE
)

# Using cross-validation instead of standard RATE
het_evidence_cv <- margot_interpret_heterogeneity(
  models = causal_forest_results,
  use_cross_validation = TRUE,
  cv_num_folds = 5,
  alpha = 0.2,  # Higher alpha recommended for Bonferroni with CV
  adjust = "bonferroni",
  parallel = TRUE,  # Enable parallel processing for faster CV
  n_cores = 4
)

# Plot CV results without recomputing
if (!is.null(het_evidence_cv$cv_results)) {
  plot <- margot_plot_cv_results(het_evidence_cv$cv_results)
  summary_plot <- margot_plot_cv_summary(het_evidence_cv$cv_results)
}

# Use standard RATE plotting functions with the raw results
# This works for both standard and CV methods
rate_results <- het_evidence$rate_results$raw_results

# Plot using standard functions
plot_autoc <- margot_plot_rate(rate_results$rate_autoc, target = "AUTOC")
plot_qini <- margot_plot_rate(rate_results$rate_qini, target = "QINI")
plot_batch <- margot_plot_rate_batch(rate_results)
}

}
